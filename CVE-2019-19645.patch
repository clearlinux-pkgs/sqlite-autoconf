From fbe04636d7d7e75f1128572340810d378104aac3 Mon Sep 17 00:00:00 2001
From: "D. Richard Hipp" <drh@hwaci.com>
Date: Mon, 9 Dec 2019 08:13:43 +0000
Subject: [PATCH] Avoid infinite recursion in the ALTER TABLE code when a view
 contains an unused CTE that references, directly or indirectly, the view
 itself.

FossilOrigin-Name: 1d2e53a39b87e364685e21de137655b6eee725e4c6d27fc90865072d7c5892b5
---
 sqlite3.c | 17 +++++++++++++----
 sqlite3.h |  2 +-
 2 files changed, 14 insertions(+), 5 deletions(-)

diff --git a/sqlite3.c b/sqlite3.c
index 2e37723..361339d 100644
--- a/sqlite3.c
+++ b/sqlite3.c
@@ -1167,7 +1167,7 @@ extern "C" {
 */
 #define SQLITE_VERSION        "3.30.1"
 #define SQLITE_VERSION_NUMBER 3030001
-#define SQLITE_SOURCE_ID      "2019-12-23 21:04:33 77f3eb9ed8d80ce36ac715396266422b86d24e6e6cc7de34f500e4c97b38alt1"
+#define SQLITE_SOURCE_ID      "2019-12-09 08:13:43 9905e06ca1fc5072f8209451bb60e967a13be60c54eb485e1fb9c5c41af1alt1"
 
 /*
 ** CAPI3REF: Run-Time Library Version Numbers
@@ -17946,6 +17946,7 @@ struct Select {
 #define SF_IncludeHidden  0x20000  /* Include hidden columns in output */
 #define SF_ComplexResult  0x40000  /* Result contains subquery or function */
 #define SF_WhereBegin     0x80000  /* Really a WhereBegin() call.  Debug Only */
+#define SF_View           0x02000 /* SELECT statement is a view */
 
 /*
 ** The results of a SELECT can be distributed in several ways, as defined
@@ -103917,6 +103918,7 @@ static int renameUnmapExprCb(Walker *pWalker, Expr *pExpr){
 static int renameUnmapSelectCb(Walker *pWalker, Select *p){
   Parse *pParse = pWalker->pParse;
   int i;
+  if( p->selFlags & SF_View ) return WRC_Prune;
   if( ALWAYS(p->pEList) ){
     ExprList *pList = p->pEList;
     for(i=0; i<pList->nExpr; i++){
@@ -104021,6 +104023,7 @@ static void renameWalkWith(Walker *pWalker, Select *pSelect){
 ** descend into sub-select statements.
 */
 static int renameColumnSelectCb(Walker *pWalker, Select *p){
+  if( p->selFlags & SF_View ) return WRC_Prune;
   renameWalkWith(pWalker, p);
   return WRC_Continue;
 }
@@ -104486,8 +104489,9 @@ static void renameColumnFunc(
   if( sParse.pNewTable ){
     Select *pSelect = sParse.pNewTable->pSelect;
     if( pSelect ){
+      pSelect->selFlags &= ~SF_View;
       sParse.rc = SQLITE_OK;
-      sqlite3SelectPrep(&sParse, sParse.pNewTable->pSelect, 0);
+      sqlite3SelectPrep(&sParse, pSelect, 0);
       rc = (db->mallocFailed ? SQLITE_NOMEM : sParse.rc);
       if( rc==SQLITE_OK ){
         sqlite3WalkSelect(&sWalker, pSelect);
@@ -104599,6 +104603,7 @@ static int renameTableSelectCb(Walker *pWalker, Select *pSelect){
   int i;
   RenameCtx *p = pWalker->u.pRename;
   SrcList *pSrc = pSelect->pSrc;
+  if( pSelect->selFlags & SF_View ) return WRC_Prune;
   if( pSrc==0 ){
     assert( pWalker->pParse->db->mallocFailed );
     return WRC_Abort;
@@ -104678,10 +104683,13 @@ static void renameTableFunc(
 
         if( pTab->pSelect ){
           if( isLegacy==0 ){
+            Select *pSelect = pTab->pSelect;
             NameContext sNC;
             memset(&sNC, 0, sizeof(sNC));
             sNC.pParse = &sParse;
 
+            assert( pSelect->selFlags & SF_View );
+            pSelect->selFlags &= ~SF_View;
             sqlite3SelectPrep(&sParse, pTab->pSelect, &sNC);
             if( sParse.nErr ) rc = sParse.rc;
             sqlite3WalkSelect(&sWalker, pTab->pSelect);
@@ -109991,6 +109999,7 @@ SQLITE_PRIVATE void sqlite3CreateView(
   ** allocated rather than point to the input string - which means that
   ** they will persist after the current sqlite3_exec() call returns.
   */
+  pSelect->selFlags |= SF_View;
   if( IN_RENAME_OBJECT ){
     p->pSelect = pSelect;
     pSelect = 0;
@@ -225067,9 +225076,9 @@ SQLITE_API int sqlite3_stmt_init(
 #endif /* !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_STMTVTAB) */
 
 /************** End of stmt.c ************************************************/
-#if __LINE__!=225070
+#if __LINE__!=225079
 #undef SQLITE_SOURCE_ID
-#define SQLITE_SOURCE_ID      "2019-12-23 21:04:33 77f3eb9ed8d80ce36ac715396266422b86d24e6e6cc7de34f500e4c97b38alt2"
+#define SQLITE_SOURCE_ID      "2019-12-09 08:13:43 9905e06ca1fc5072f8209451bb60e967a13be60c54eb485e1fb9c5c41af1alt2"
 #endif
 /* Return the source-id for this library */
 SQLITE_API const char *sqlite3_sourceid(void){ return SQLITE_SOURCE_ID; }
diff --git a/sqlite3.h b/sqlite3.h
index d2cd68b..d31cc23 100644
--- a/sqlite3.h
+++ b/sqlite3.h
@@ -125,7 +125,7 @@ extern "C" {
 */
 #define SQLITE_VERSION        "3.30.1"
 #define SQLITE_VERSION_NUMBER 3030001
-#define SQLITE_SOURCE_ID      "2019-12-23 21:04:33 77f3eb9ed8d80ce36ac715396266422b86d24e6e6cc7de34f500e4c97b38alt1"
+#define SQLITE_SOURCE_ID      "2019-12-09 08:13:43 9905e06ca1fc5072f8209451bb60e967a13be60c54eb485e1fb9c5c41af1alt1"
 
 /*
 ** CAPI3REF: Run-Time Library Version Numbers
-- 
2.24.1

